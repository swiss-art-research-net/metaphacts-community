/*
 * "Commons Clause" License Condition v1.0
 *
 * The Software is provided to you by the Licensor under the
 * License, as defined below, subject to the following condition.
 *
 * Without limiting other conditions in the License, the grant
 * of rights under the License will not include, and the
 * License does not grant to you, the right to Sell the Software.
 *
 * For purposes of the foregoing, "Sell" means practicing any
 * or all of the rights granted to you under the License to
 * provide to third parties, for a fee or other consideration
 * (including without limitation fees for hosting or
 * consulting/ support services related to the Software), a
 * product or service whose value derives, entirely or substantially,
 * from the functionality of the Software. Any
 * license notice or attribution required by the License must
 * also include this Commons Clause License Condition notice.
 *
 * License: LGPL 2.1 or later
 * Licensor: metaphacts GmbH
 *
 * Copyright (C) 2015-2021, metaphacts GmbH
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, you can receive a copy
 * of the GNU Lesser General Public License from http://www.gnu.org/
 */
package com.metaphacts.plugin;

import java.lang.reflect.Field;
import java.util.Optional;
import java.util.TreeSet;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.pf4j.DefaultPluginClasspath;
import org.pf4j.PluginClasspath;

import com.metaphacts.util.ReflectionUtil;

public class PlatformPluginClasspath extends PluginClasspath {
    private static final Logger logger = LogManager.getLogger(PlatformPluginClasspath.class);
    
    /**
     * The development plugin classpath for classic Eclipse projects.
     * The classes directory is {@code bin/main}.
     */
    public static final PluginClasspath ECLIPSE_CLASSIC = new PluginClasspath().addClassesDirectories("bin");
    /**
     * The development plugin classpath for Eclipse generated using <a href="https://gradle.org">Gradle</a>.
     * The classes directory is {@code bin/main}.
     */
    public static final PluginClasspath ECLIPSE_GRADLE = new PluginClasspath().addClassesDirectories("bin/main");
    /**
     * The development plugin classpath for <a href="https://gradle.org">Gradle</a>.
     * The classes directories are {@code target/classes/java/main, target/resources/main}.
     */
    public static final PluginClasspath GRADLE_MODIFIED = new PluginClasspath().addClassesDirectories("target/classes/java/main", "target/resources/main")
                                                                                .addJarsDirectories("target/libs", "target/deploy/lib");
    
    public PlatformPluginClasspath() {
        ensureOrderedClasspath();
        
        addClassesDirectories(DefaultPluginClasspath.CLASSES_DIR);
        addJarsDirectories(DefaultPluginClasspath.LIB_DIR);

        // this path contains the plugin's code (classes and/or jar) compiled 
        // and packaged during local build as well as all resolved dependencies
        addClassesDirectories(GRADLE_MODIFIED.getClassesDirectories());
        addJarsDirectories(GRADLE_MODIFIED.getJarsDirectories());

        // note: the following commented class path definitions locate class files and libs in 
        // folder generated by different variations of build steps, i.e. by Gradle, Eclipse, ...
        // 
        /*
        addClassesDirectories(ECLIPSE_GRADLE.getClassesDirectories());
        addClassesDirectories(ECLIPSE_CLASSIC.getClassesDirectories());
        addClassesDirectories(GRADLE_MODIFIED.getClassesDirectories());
        addClassesDirectories(DevelopmentPluginClasspath.MAVEN.getClassesDirectories());
        addClassesDirectories(DevelopmentPluginClasspath.GRADLE.getClassesDirectories());
        addClassesDirectories(DevelopmentPluginClasspath.KOTLIN.getClassesDirectories());
        addClassesDirectories(DevelopmentPluginClasspath.IDEA.getClassesDirectories());

        addJarsDirectories(ECLIPSE_GRADLE.getJarsDirectories());
        addJarsDirectories(ECLIPSE_CLASSIC.getJarsDirectories());
        addJarsDirectories(GRADLE_MODIFIED.getJarsDirectories());
        addJarsDirectories(DevelopmentPluginClasspath.MAVEN.getJarsDirectories());
        addJarsDirectories(DevelopmentPluginClasspath.GRADLE.getJarsDirectories());
        addJarsDirectories(DevelopmentPluginClasspath.KOTLIN.getJarsDirectories());
        addJarsDirectories(DevelopmentPluginClasspath.IDEA.getJarsDirectories());
        */
    }

    private void ensureOrderedClasspath() {
        // ensure that the classpath entries are returned in the order they are set
        useOrderedSet("classesDirectories");
        useOrderedSet("jarsDirectories");
    }

    private void useOrderedSet(String fieldName) {
        final Object that = this;
        Optional<Field> fieldResult = ReflectionUtil.findField(getClass(), fieldName);
        if (!fieldResult.isPresent()) {
            logger.warn("Cannot use TreeSet for " + fieldName + ": field not found");
        }
        fieldResult.ifPresent(field -> {
            field.setAccessible(true);
            try {
                field.set(that, new TreeSet<String>());
            } catch (Exception e) {
                logger.warn("Failed to use TreeSet for " + fieldName + ":" + e.getMessage());
            }
        });
    }
}
