/*
 * "Commons Clause" License Condition v1.0
 *
 * The Software is provided to you by the Licensor under the
 * License, as defined below, subject to the following condition.
 *
 * Without limiting other conditions in the License, the grant
 * of rights under the License will not include, and the
 * License does not grant to you, the right to Sell the Software.
 *
 * For purposes of the foregoing, "Sell" means practicing any
 * or all of the rights granted to you under the License to
 * provide to third parties, for a fee or other consideration
 * (including without limitation fees for hosting or
 * consulting/ support services related to the Software), a
 * product or service whose value derives, entirely or substantially,
 * from the functionality of the Software. Any
 * license notice or attribution required by the License must
 * also include this Commons Clause License Condition notice.
 *
 * License: LGPL 2.1 or later
 * Licensor: metaphacts GmbH
 *
 * Copyright (C) 2015-2021, metaphacts GmbH
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, you can receive a copy
 * of the GNU Lesser General Public License from http://www.gnu.org/
 */
import type { ComponentClass, FunctionComponent } from 'react';

/**
 * That is a special require, custom-components module will be generated by
 * webpack custom componentsLoader that uses component.json file to create
 * set of dynamic 'System.import' for web components.
 */
const getBundleLoader = require('platform-components') as
  ((tagName: string) => ComponentEntry | null) &
  { readonly allTags: ReadonlyArray<string> };

interface ComponentEntry {
  loader: () => Promise<{ default: ReactComponentType } | ReactComponentType | string>;
  isNative?: boolean;
  metadata?: ComponentMetadata | null;
}

type ReactComponentType = ComponentClass | FunctionComponent;

export interface ComponentMetadata {
  deferAttributes?: { [attrName: string]: boolean };
  deferJsonProperties?: { [attrName: string]: DeferredJsonProperties };
  propsSchema?: string;
  helpResource?: string;
}

export interface DeferredJsonProperties {
  [jsonKey: string]: boolean;
}

const registeredComponents = new Map<string, ComponentEntry>();

export function registerNativeComponent(
  tagName: string,
  loader: () => Promise<void>,
  metadata: ComponentMetadata | null = null
) {
  if (hasComponent(tagName)) {
    throw new Error(`Cannot register native web component for existing tag "${tagName}"`);
  }
  registeredComponents.set(tagName, {
    loader: () => loader().then(() => tagName),
    metadata,
  });
}

const loadingComponents = new Map<string, Promise<ReactComponentType | string>>();
const cachedComponents = new Map<string, ReactComponentType | string>();

/**
 * Asynchronously load JS file for React based web-component.
 */
export function loadComponent(tagName: string): Promise<ReactComponentType | string> {
  if (cachedComponents.has(tagName)) {
    return Promise.resolve(cachedComponents.get(tagName));
  }
  if (loadingComponents.has(tagName)) {
    return loadingComponents.get(tagName);
  }
  const entry = getComponentEntry(tagName);
  if (entry) {
    const task = entry.loader().then((bundle: any) => {
      const comp = bundle.default ? bundle.default : bundle;
      if (!cachedComponents.has(tagName)) {
        cachedComponents.set(tagName, comp);
        loadingComponents.delete(tagName);
      }
      return comp;
    });
    loadingComponents.set(tagName, task);
    return task;
  } else {
    return Promise.reject(`Cannot find component <${tagName}>`);
  }
}

export function loadComponentSync(tagName: string): ReactComponentType | string {
  if (cachedComponents.has(tagName)) {
    return cachedComponents.get(tagName);
  }

  if (hasComponent(tagName)) {
    throw new Error(`Cannot synchronously load component <${tagName}> as it is not preloaded`);
  } else {
    throw new Error(`Cannot find component <${tagName}>`);
  }
}

export async function loadComponents(tags: ReadonlySet<string>): Promise<void> {
  const componentsToLoad: string[] = [];
  tags.forEach(component => {
    if (!hasCachedComponent(component) && hasComponent(component)) {
      componentsToLoad.push(component);
    }
  });
  if (componentsToLoad.length > 0) {
    await Promise.all(
      componentsToLoad.map(tag => loadComponent(tag))
    );
  }
}

export function hasCachedComponent(tagName: string): boolean {
  return cachedComponents.has(tagName);
}

/**
 * Check if there is React component that corresponds to tagName.
 */
export function hasComponent(tagName: string): boolean {
  const entry = getComponentEntry(tagName);
  return Boolean(entry);
}

export function isRegisteredNativeComponent(tagName: string) {
  const entry = getComponentEntry(tagName);
  if (!entry) {
    throw new Error(`Cannot find component <${tagName}>`);
  }
  return Boolean(entry.isNative);
}

function getComponentEntry(tagName: string): ComponentEntry | undefined {
  const bundleEntry = getBundleLoader(tagName);
  return bundleEntry ?? registeredComponents.get(tagName);
}

export function getComponentMetadata(tagName: string): ComponentMetadata | null | undefined {
  const entry = getComponentEntry(tagName);
  if (!entry) {
    throw new Error(`Cannot find component <${tagName}>`);
  }
  return entry.metadata;
}

export interface ComponentClassMetadata {
  __htmlTag?: string;
}

export function getAllComponents() {
  return getBundleLoader.allTags;
}
