/*
 * "Commons Clause" License Condition v1.0
 *
 * The Software is provided to you by the Licensor under the
 * License, as defined below, subject to the following condition.
 *
 * Without limiting other conditions in the License, the grant
 * of rights under the License will not include, and the
 * License does not grant to you, the right to Sell the Software.
 *
 * For purposes of the foregoing, "Sell" means practicing any
 * or all of the rights granted to you under the License to
 * provide to third parties, for a fee or other consideration
 * (including without limitation fees for hosting or
 * consulting/ support services related to the Software), a
 * product or service whose value derives, entirely or substantially,
 * from the functionality of the Software. Any
 * license notice or attribution required by the License must
 * also include this Commons Clause License Condition notice.
 *
 * License: LGPL 2.1 or later
 * Licensor: metaphacts GmbH
 *
 * Copyright (C) 2015-2020, metaphacts GmbH
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, you can receive a copy
 * of the GNU Lesser General Public License from http://www.gnu.org/
 */
import { Component } from 'react';
import * as SparqlJs from 'sparqljs';
import {
  SparqlDataProvider, SparqlDataProviderSettings, SparqlDataProviderOptions, SparqlQueryMethod,
  SparqlResponse, Dictionary, ElementModel, PropertyConfiguration, LinkConfiguration,
} from 'ontodia';
import * as Kefir from 'kefir';

import { WrappingError } from 'platform/api/async';
import { getBaseUrl } from 'platform/api/http';
import { Rdf } from 'platform/api/rdf';
import { xsd } from 'platform/api/rdf/vocabularies';
import {
  SparqlClient, SparqlUtil, SparqlTypeGuards, VariableRenameBinder,
} from 'platform/api/sparql';
import { getLabels } from 'platform/api/services/resource-label';

import { FieldDefinition } from 'platform/components/forms';

import { FieldConfiguration } from '../authoring/FieldConfigurationCommon';
import { OwlNoStatsSettings } from './DataProviderProfiles';
import * as DiagramService from './DiagramService';
import { DataProviderComponent, CreateDataProviderParams } from './OntodiaDataProviders';

/**
 * Allows configuring how `ontodia` fetches data.
 */
export interface OntodiaSparqlDataProviderConfig {
  /**
   * Repository ID.
   */
  repository?: string;
  /**
   * Sparql SELECT query to get images of elements.
   *
   * Parametrized with `VALUES(?element) {...}` and should contains the following bindings:
   *  - `?element`: IRI of element on graph;
   *  - `?image`: image of the element.
   */
  imageQuery?: string;
  /**
   * Array of link types to get images of elements.
   * If property imageQuery is defined, this property will be ignored.
   */
  imageIris?: string[];
  /**
   * Sparql data provider settings to override default settings.
   * See definition of `SparqlDataProviderSettings`.
   */
  providerSettings?: SparqlDataProviderSettings;
  /**
   * Allow blank nodes in navigation queries. Significantly increases complexity of the queries
   * and may lead to unexpected query execution plans and timeouts in triple stores.
   *
   * @default false
   */
  acceptBlankNodes?: boolean;
}

export type OntodiaSparqlDataProviderProps = OntodiaSparqlDataProviderConfig;

export class OntodiaSparqlDataProvider extends Component<OntodiaSparqlDataProviderProps, {}>
  implements DataProviderComponent {
  static defaultProps: Partial<OntodiaSparqlDataProviderProps> = {
    repository: 'default',
    // disable blank nodes support to prevent too complex queries to be generated by default
    acceptBlankNodes: false,
  };

  render(): null {
    return null;
  }

  createDataProvider(params: CreateDataProviderParams): SparqlDataProvider {
    const {fieldConfiguration} = params;
    const {repository, providerSettings, imageIris, acceptBlankNodes} = this.props;

    // this is workaround for field-based navigation
    const fieldConfigDefaults = createFieldBasedConfiguration(fieldConfiguration);

    const effectiveSettings: SparqlDataProviderSettings = {
      ...OwlNoStatsSettings,
      ...fieldConfigDefaults,
      ...providerSettings,
    };
    const options: SparqlDataProviderOptions = {
      factory: Rdf.DATA_FACTORY,
      endpointUrl: getEndpointUrlForRepository(repository),
      prepareImages: this.prepareImages,
      prepareLabels: this.prepareLabels,
      imagePropertyUris: imageIris,
      queryMethod: SparqlQueryMethod.POST,
      acceptBlankNodes: acceptBlankNodes,
    };
    return new PlatformDataProvider(options, effectiveSettings);
  }

  initializeDataProvider(dataProvider: SparqlDataProvider): Kefir.Property<void> {
    return Kefir.constant(undefined);
  }

  getName(): string {
    return `${this.props.repository}-sparql`;
  }

  private prepareImages = (elementsInfo: Dictionary<ElementModel>): Promise<Dictionary<string>> => {
    const {repository, imageQuery, imageIris} = this.props;

    if (!imageQuery && !imageIris) {
      return DiagramService.fetchThumbnails(elementsInfo, {repository});
    } else if (imageQuery) {
      return DiagramService.prepareImages(elementsInfo, imageQuery);
    }
    return Promise.resolve({});
  }

  private prepareLabels = (resources: Set<string>): Promise<Map<string, Rdf.Literal[]>> => {
    const {repository} = this.props;
    const iris = Array.from(resources, Rdf.iri);
    return getLabels(iris, {context: {repository}})
      .map(labels => {
        const result = new Map<string, Rdf.Literal[]>();
        labels.forEach((label, iri) => {
          const literal = Rdf.literal(label);
          result.set(iri.value, [literal]);
        });
        return result;
      })
      .toPromise();
  }
}

class PlatformDataProvider extends SparqlDataProvider {
  private readonly sparqlOptions: SparqlClient.SparqlOptions;

  constructor(
    options: SparqlDataProviderOptions,
    settings: SparqlDataProviderSettings
  ) {
    super(options, settings);
    this.sparqlOptions = {endpoint: options.endpointUrl};
  }

  executeSparqlQuery<Binding>(query: string): Promise<SparqlResponse<Binding>> {
    return SparqlClient.selectStar(query, this.sparqlOptions)
      .toPromise() as Promise<SparqlResponse<any>>;
  }

  executeSparqlConstruct(query: string): Promise<Rdf.Quad[]> {
    return SparqlClient.construct(query, this.sparqlOptions).toPromise();
  }
}

function getEndpointUrlForRepository(repository: string) {
  const baseEndpointUrl = getBaseUrl() ? getBaseUrl() + '/sparql' : '/sparql';
  return `${baseEndpointUrl}?repository=${repository}`;
}

function createFieldBasedConfiguration(
  fieldConfiguration: FieldConfiguration
): Partial<SparqlDataProviderSettings> {
  const linkConfigurations = createLinkConfigurations(fieldConfiguration.allFields);
  const propertyConfigurations = createPropertyConfiguration(
    fieldConfiguration.allFields,
    fieldConfiguration.datatypeFields
  );

  let fieldConfigDefaults: Partial<SparqlDataProviderSettings> = {
    linkConfigurations, propertyConfigurations
  };
  if (linkConfigurations.length > 0) {
    fieldConfigDefaults = {
      ...fieldConfigDefaults,
      elementInfoQuery: `
        CONSTRUCT {
            ?inst rdf:type ?class .
            ?inst rdfs:label ?label .
            ?inst ?propType ?propValue.
        } WHERE {
            VALUES (?inst) {\${ids}}
            OPTIONAL { ?inst a ?class }
            OPTIONAL { ?inst \${dataLabelProperty} ?label }
            OPTIONAL {
              \${propertyConfigurations}
            }
        }
      `,
    };
  }
  return fieldConfigDefaults;
}

function createLinkConfigurations(
  fields?: ReadonlyArray<FieldDefinition>
): LinkConfiguration[] {
  if (!fields || fields.length === 0) {
    return [];
  }
  return fields
    .filter(field => {
      // if it's non-literal field or at least have something in range
      return xsd.anyURI.equals(field.xsdDatatype);
    })
    .map(fieldToLinkConfig);
}

function createPropertyConfiguration(
  fields?: ReadonlyArray<FieldDefinition>, forceFields?: ReadonlyMap<string, FieldDefinition>
): PropertyConfiguration[] {
  if (!fields || fields.length === 0) {
    return [];
  }
  return fields
    .filter(field => {
      // pass only literal values
      return (forceFields && forceFields.has(field.iri)) || !xsd.anyURI.equals(field.xsdDatatype);
    })
    .map(fieldToPropertyConfig);
}

function fieldToLinkConfig(field: FieldDefinition): LinkConfiguration {
  const parsedQuery = parseSelectPattern(field);
  const domain = field.domain ? field.domain.map(iri => iri.value) : undefined;

  const directPredicate = parseDirectPredicate(parsedQuery.where);
  if (directPredicate) {
    return {id: field.iri, domain, path: directPredicate};
  }

  new VariableRenameBinder('subject', 'source').query(parsedQuery);
  new VariableRenameBinder('value', 'target').query(parsedQuery);

  return {
    id: field.iri,
    domain,
    path: serializePatterns(parsedQuery.where),
  };
}

function fieldToPropertyConfig(field: FieldDefinition): PropertyConfiguration {
  const parsedQuery = parseSelectPattern(field);
  const domain = field.domain ? field.domain.map(iri => iri.value) : undefined;

  const directPredicate = parseDirectPredicate(parsedQuery.where);
  if (directPredicate) {
    return {id: field.iri, domain, path: directPredicate};
  }

  new VariableRenameBinder('subject', 'inst').query(parsedQuery);
  /* keep the same name for 'value' variable */

  return {
    id: field.iri,
    domain,
    path: serializePatterns(parsedQuery.where),
  };
}

function parseSelectPattern(field: FieldDefinition): SparqlJs.SelectQuery {
  if (!field.selectPattern) {
    throw new Error(`Expected a selectPattern for field: ${field.iri}`);
  }
  let parsedQuery: SparqlJs.SelectQuery;
  try {
    parsedQuery = SparqlUtil.parseQuery(field.selectPattern);
  } catch (err) {
    throw new WrappingError(`Failed to parse selectPattern for field: ${field.iri}`, err);
  }
  if (!(parsedQuery.type === 'query' && parsedQuery.queryType === 'SELECT')) {
    throw new Error(`Expected a SELECT query in selectPattern for field: ${field.iri}`);
  }
  return parsedQuery;
}

function serializePatterns(patterns: SparqlJs.Pattern[]): string {
  const simpleQuery: SparqlJs.SelectQuery = {
    type: 'query',
    queryType: 'SELECT',
    variables: [new SparqlJs.Wildcard()],
    prefixes: {},
    where: patterns,
  };
  const query = SparqlUtil.serializeQuery(simpleQuery);
  const prefixLength = 'SELECT * WHERE { '.length;
  const serialized = query.substr(prefixLength, query.length - prefixLength - 2);
  return serialized;
}

function parseDirectPredicate(patterns: SparqlJs.Pattern[]): string | undefined {
  const {isIri, isVariable} = SparqlTypeGuards;

  let predicate: SparqlJs.IriTerm | undefined;
  for (const pattern of patterns) {
    switch (pattern.type) {
      case 'bgp':
        for (const t of pattern.triples) {
          if (isVariable(t.subject) && t.subject.value === 'subject'
            && isVariable(t.object) && t.object.value === 'value'
            && isIri(t.predicate)
          ) {
            predicate = t.predicate;
          } else if (isVariable(t.object) && t.object.value === 'label') {
            // ignore
          } else {
            // pattern is too complex
            return undefined;
          }
        }
        break;
      case 'bind':
        // ignore
        break;
      default:
        // pattern is too complex
        return undefined;
    }
  }
  return predicate ? predicate.value : undefined;
}

export default OntodiaSparqlDataProvider;
